/*
  ____  _     _____         _             _
 | __ )| |   | ____|  _ __ | |_   _  __ _(_)_ __
 |  _ \| |   |  _|   | '_ \| | | | |/ _` | | '_ \
 | |_) | |___| |___  | |_) | | |_| | (_| | | | | |
 |____/|_____|_____| | .__/|_|\__,_|\__, |_|_| |_|
                     |_|            |___/
# A Template for Ble_pluginPlugin, a Source Plugin
# Generated by the command: plugin -t source -d ble_plugin BLE_plugin
# Hostname: Fram-IV.local
# Current working directory: /Users/p4010/Develop/MADS_plugins
# Creation date: 2024-08-05T14:03:32.554+0200
# NOTICE: MADS Version 1.0.2
*/
// Mandatory included headers
#include <nlohmann/json.hpp>
#include <pugg/Kernel.h>
#include <source.hpp>
// other includes as needed here
#include <csignal>
#include <simpleble/SimpleBLE.h>
#include <thread>
#include <unistd.h>
#include <vector>

// Define the name of the plugin
#ifndef PLUGIN_NAME
#define PLUGIN_NAME "ble_plugin"
#endif

// Load the namespaces
using namespace std;
using json = nlohmann::json;
using namespace SimpleBLE;
using namespace std::chrono_literals;

typedef union {
  char b[4];
  uint32_t v;
} ba_t;

// Plugin class. This shall be the only part that needs to be modified,
// implementing the actual functionality
class BlePlugin : public Source<json> {

public:
  // Typically, no need to change this
  string kind() override { return PLUGIN_NAME; }

  ~BlePlugin() { _peripheral.disconnect(); }

  return_type get_output(json &out,
                         std::vector<unsigned char> *blob = nullptr) override {
    ba_t value;
    out.clear();
    // reading asynchronous notifications
    if (_params["subscribe"]) {
      auto missing = sleep(2000);
      if (missing == 0) {
        return return_type::retry;
      }
    } else {
      // reading repeating updates
      for (auto &uuid : _uuids) {
        try {
          if (!_peripheral.is_connected()) {
            connect();
          }
          strncpy(
              value.b,
              (char const *)_peripheral.read(uuid.first, uuid.second).data(),
              4);
          _payload[short_uuid(uuid.second)] = value.v;
        } catch (exception &e) {
          if (!_params["silent"])
            cerr << "Error: " << e.what() << endl;
          return return_type::error;
        }
      }
    }
    out["payload"] = _payload;
    _payload.clear();
    if (!_agent_id.empty())
      out["agent_id"] = _agent_id;
    return return_type::success;
  }

  void set_params(void const *params) override {
    Source::set_params(params);
    _params["silent"] = false;
    _params["list_peripherals"] = false;
    _params["characteristics"] = json::array();
    _params["subscribe"] = false;
    _params.merge_patch(*(json *)params);

    if (!_params["characteristics"].is_array())
      throw runtime_error("Characteristics parameter must be an array!");

    connect();
  }

  map<string, string> info() override {
    return {{"peripheral", {_params["peripheral"].get<string>()}}};
  };

private:
  string short_uuid(BluetoothUUID uuid) {
    string key = uuid.substr(0, uuid.find("-"));
    if (key.size() > 0)
      key.erase(0, key.find_first_not_of('0'));
    return key;
  }

  void connect() {
    vector<Adapter> adapters = Adapter::get_adapters();
    bool found = false;
    _uuids.clear();
    _adapter = adapters[0];

    _adapter.set_callback_on_scan_start([&]() {
      if (!_params["silent"])
        cerr << "Start searching for: " << _params["peripheral"].get<string>()
             << endl;
    });

    _adapter.set_callback_on_scan_stop([&]() {
      if (!_params["silent"])
        cerr << "Found peripheral: " << _peripheral.identifier()
             << ", address: " << _peripheral.address()
             << ", rssi: " << _peripheral.rssi() << endl;
    });

    _adapter.set_callback_on_scan_found([&](SimpleBLE::Peripheral peripheral) {
      if (_params["list_uuids"])
        cerr << peripheral.address() << ": "
             << " name: " << setw(15) << peripheral.identifier()
             << ", rssi: " << peripheral.rssi() << endl;
      if (peripheral.identifier() == _params["peripheral"].get<string>()) {
        found = true;
        _peripheral = peripheral;
      }
    });

    _adapter.scan_start();
    while (!found) {
      this_thread::sleep_for(100ms);
    }
    _adapter.scan_stop();
    _peripheral.connect();

    for (auto &service : _peripheral.services()) {
      if (_params["list_uuids"])
        cerr << "  Service: " << service.uuid() << endl;

      for (auto &characteristic : service.characteristics()) {
        json ch = _params["characteristics"];
        BluetoothUUID uuid = characteristic.uuid();
        bool use_it =
            (ch.empty() || find(ch.begin(), ch.end(), uuid) != end(ch));
        if (_params["list_uuids"])
          cerr << "    Characteristic: " << characteristic.uuid()
               << (use_it ? " *" : "") << endl;

        if (use_it) {
          _uuids.push_back(make_pair(service.uuid(), uuid));
          if (_params["subscribe"])
            subscribe_notifications(service, characteristic);
        }
      }
    }
  }

  void subscribe_notifications(Service &s, Characteristic &c) {
    if (!c.can_notify()) {
      throw runtime_error("Characteristics do not support notify");
    }
    // Disable signal, used by sleep
    signal(SIGUSR1, [](int){});

    if (!_params["silent"])
      cerr << "Setting notification for " << s.uuid() << ", " << c.uuid()
           << endl;

    _peripheral.notify(s.uuid(), c.uuid(), [&, c, s](ByteArray bytes) {
      Characteristic cc = c;
      Service sc = s;
      ba_t value;
      strncpy(value.b, (char const *)bytes.data(), 4);
      _payload[short_uuid(cc.uuid())] = value.v;
      raise(SIGUSR1);
    });
  }

private:
  // Define the fields that are used to store internal resources
  Adapter _adapter;
  Peripheral _peripheral;
  vector<pair<BluetoothUUID, BluetoothUUID>> _uuids;
  json _payload = {};
  vector<string> _characteristics;
};

/*
  ____  _             _             _      _
 |  _ \| |_   _  __ _(_)_ __     __| |_ __(_)_   _____ _ __
 | |_) | | | | |/ _` | | '_ \   / _` | '__| \ \ / / _ \ '__|
 |  __/| | |_| | (_| | | | | | | (_| | |  | |\ V /  __/ |
 |_|   |_|\__,_|\__, |_|_| |_|  \__,_|_|  |_| \_/ \___|_|
                |___/
Enable the class as plugin
*/
INSTALL_SOURCE_DRIVER(BlePlugin, json)

/*
                  _
  _ __ ___   __ _(_)_ __
 | '_ ` _ \ / _` | | '_ \
 | | | | | | (_| | | | | |
 |_| |_| |_|\__,_|_|_| |_|

For testing purposes, when directly executing the plugin
*/

static bool running = true;

int main(int argc, char const *argv[]) {
  BlePlugin plugin;
  json output, params;

  // Set example values to params
  params["peripheral"] = "Arduino";
  params["list_uuids"] = true;
  params["characteristics"] = {// "00002a57-0000-1000-8000-00805f9b34fb",
                               // "00002a58-0000-1000-8000-00805f9b34fb",
                               "00002a59-0000-1000-8000-00805f9b34fb"};
  params["subscribe"] = (argc > 1);

  // Set the parameters
  plugin.set_params(&params);

  signal(SIGINT, [](int) { running = false; });
  while (running) {
    // Process data
    plugin.get_output(output);

    // Produce output
    cout << "Output: " << output << endl;

    this_thread::sleep_for(250ms);
  }
  cout << "Exiting..." << endl;
  return 0;
}
